# ‡πÉ‡∏ö‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á: B-Tree

## ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
1. ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á B-Tree
2. ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ B-Tree ‡∏ó‡∏µ‡πà‡∏°‡∏µ Order ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÑ‡∏î‡πâ
3. ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ B-Tree ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡πÅ‡∏•‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ
4. ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á splitting ‡πÅ‡∏•‡∏∞ merging ‡πÉ‡∏ô B-Tree

## ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
1. ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå
2. ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° IDE ‡∏´‡∏£‡∏∑‡∏≠ Text Editor ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏†‡∏≤‡∏©‡∏≤ Python
3. ‡πÉ‡∏ö‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

## ‡∏ó‡∏§‡∏©‡∏é‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á

### B-Tree ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£
B-Tree ‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏™‡∏≥‡∏£‡∏≠‡∏á ‡πÇ‡∏î‡∏¢‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (data) ‡∏Ñ‡∏π‡πà‡∏Å‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏µ‡∏¢‡πå (key) ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡πÑ‡∏î‡πâ ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

### Order ‡πÉ‡∏ô B-Tree
Order (m) ‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏ô B-Tree ‡πÇ‡∏î‡∏¢‡∏°‡∏µ‡∏ú‡∏•‡∏ï‡πà‡∏≠‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ:

1. ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏π‡πà key-data ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î:
   - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: m-1 ‡∏Ñ‡∏π‡πà
   - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î: ‚åàm/2‚åâ-1 ‡∏Ñ‡∏π‡πà (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô root)
   
2. ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î:
   - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: m ‡∏•‡∏π‡∏Å
   - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î: ‚åàm/2‚åâ ‡∏•‡∏π‡∏Å (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô root)

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: B-Tree order 3
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏°‡∏µ key ‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î 2 ‡∏ï‡∏±‡∏ß (3-1)
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏°‡∏µ key ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ 1 ‡∏ï‡∏±‡∏ß (‚åà3/2‚åâ-1)
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏°‡∏µ‡∏•‡∏π‡∏Å‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î 3 ‡πÇ‡∏´‡∏ô‡∏î
- ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏•‡∏π‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡πÇ‡∏´‡∏ô‡∏î (‚åà3/2‚åâ)

### ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô B-Tree
1. ‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:
   - B-Tree ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (data) ‡πÑ‡∏ß‡πâ‡∏Å‡∏±‡∏ö key ‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÇ‡∏´‡∏ô‡∏î
   - ‡πÅ‡∏ï‡πà‡∏•‡∏∞ key ‡∏à‡∏∞‡∏°‡∏µ data field ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠ pointer ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
   - ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏û‡∏ö‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà root node

2. ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö B+ Tree:
   
   B-Tree:
   - ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÇ‡∏´‡∏ô‡∏î
   - ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏à‡∏≠‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏ö‡∏ô
   - ‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
   - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö random access

   B+ Tree:
   - ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà leaf nodes
   - ‡πÇ‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á
   - ‡∏°‡∏µ linked list ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á leaf nodes
   - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö range query

### ‡∏ú‡∏•‡∏Ç‡∏≠‡∏á Order ‡∏ï‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
1. Order ‡∏ô‡πâ‡∏≠‡∏¢ (‡πÄ‡∏ä‡πà‡∏ô 3, 4):
   - ‡∏Ç‡πâ‡∏≠‡∏î‡∏µ: ‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡πâ‡∏≠‡∏¢, ‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß
   - ‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢: ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏≤‡∏à‡∏™‡∏π‡∏á, ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏≠‡∏≤‡∏à‡∏ä‡πâ‡∏≤

2. Order ‡∏°‡∏≤‡∏Å (‡πÄ‡∏ä‡πà‡∏ô 100, 200):
   - ‡∏Ç‡πâ‡∏≠‡∏î‡∏µ: ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÄ‡∏ï‡∏µ‡πâ‡∏¢, ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏£‡πá‡∏ß
   - ‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢: ‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏°‡∏≤‡∏Å, ‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏à‡∏ä‡πâ‡∏≤

### ‡∏Å‡∏≤‡∏£‡∏ô‡∏≥ B-Tree ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á
1. ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Database Management Systems)
   - MySQL ‡πÉ‡∏ä‡πâ B-Tree ‡πÅ‡∏•‡∏∞ B+Tree ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Index
   - PostgreSQL ‡πÉ‡∏ä‡πâ B-Tree ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Primary Key ‡πÅ‡∏•‡∏∞ Index
   - Oracle Database ‡πÉ‡∏ä‡πâ B-Tree ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Index

2. ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ (Inventory Management Systems)
   - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ (SKU) ‡πÅ‡∏•‡∏∞‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö
   - ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏ö‡∏ö real-time
   - ‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏

3. ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤ (Student Registration Systems)
   - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô
   - ‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ô
   - ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô

4. ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå (File Systems)
   - NTFS ‡∏Ç‡∏≠‡∏á Windows
   - HFS+ ‡∏Ç‡∏≠‡∏á Mac OS X
   - Ext4 ‡∏Ç‡∏≠‡∏á Linux

5. ‡∏£‡∏∞‡∏ö‡∏ö DNS (Domain Name System)
   - ‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡πÅ‡∏•‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ domain name
   - ‡∏£‡∏∞‡∏ö‡∏ö cache ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö DNS resolver

### ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏Ç‡∏≠‡∏á B-Tree
- ‡πÄ‡∏õ‡πá‡∏ô Self-balancing tree (‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
- ‡∏ó‡∏∏‡∏Å‡πÉ‡∏ö (leaf) ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏à‡∏∞‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô key ‡πÄ‡∏™‡∏°‡∏≠ 1 ‡∏ï‡∏±‡∏ß
- ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô key ‡∏à‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å‡∏à‡∏≤‡∏Å‡∏ã‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏Ç‡∏ß‡∏≤
- ‡∏•‡∏π‡∏Å‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á key ‡∏à‡∏∞‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ key
- ‡∏•‡∏π‡∏Å‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á key ‡∏à‡∏∞‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ key
- ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÇ‡∏´‡∏ô‡∏î ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞ leaf nodes

## ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á

### ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 1: ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree Node ‡πÅ‡∏•‡∏∞ B-Tree

```python
class BTreeNode:
    def __init__(self, leaf=True):
        # leaf: ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÇ‡∏´‡∏ô‡∏î‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        self.leaf = leaf
        # keys: ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ key ‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å
        self.keys = []
        # data: ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏Å‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ key
        self.data = []
        # children: ‡πÄ‡∏Å‡πá‡∏ö pointer ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡∏π‡∏Å‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î
        self.children = []

class BTree:
    def __init__(self, order):
        # root: pointer ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÇ‡∏´‡∏ô‡∏î root
        self.root = None
        # order: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô key ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î
        self.order = order
        
    def get_min_keys(self):
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô key ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ
        return (self.order // 2) - 1 if self.order % 2 == 0 else self.order // 2
        
    def get_max_keys(self):
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô key ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏°‡∏µ‡πÑ‡∏î‡πâ
        return self.order - 1
```

### ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 2: ‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô B-Tree

```python
def insert(self, key, data):
    # ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ root
    if self.root is None:
        self.root = BTreeNode()
        self.root.keys.append(key)
        self.root.data.append(data)
        return
        
    # ‡∏ñ‡πâ‡∏≤ root ‡πÄ‡∏ï‡πá‡∏°
    if len(self.root.keys) == self.get_max_keys():
        new_root = BTreeNode(leaf=False)
        new_root.children.append(self.root)
        self._split_child(new_root, 0)
        self.root = new_root
        
    self._insert_non_full(self.root, key, data)

def _insert_non_full(self, node, key, data):
    i = len(node.keys) - 1
    
    if node.leaf:
        # ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÅ‡∏ó‡∏£‡∏Å key ‡πÅ‡∏•‡∏∞ data
        while i >= 0 and key < node.keys[i]:
            i -= 1
        i += 1
        node.keys.insert(i, key)
        node.data.insert(i, data)
    else:
        # ‡∏´‡∏≤ child ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        while i >= 0 and key < node.keys[i]:
            i -= 1
        i += 1
        
        if len(node.children[i].keys) == self.get_max_keys():
            self._split_child(node, i)
            if key > node.keys[i]:
                i += 1
                
        self._insert_non_full(node.children[i], key, data)

def _split_child(self, parent, i):
    order = self.order
    child = parent.children[i]
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏´‡∏°‡πà
    new_node = BTreeNode(child.leaf)
    
    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
    mid = order // 2
    
    # ‡∏¢‡πâ‡∏≤‡∏¢ keys ‡πÅ‡∏•‡∏∞ data ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏´‡∏°‡πà
    new_node.keys = child.keys[mid:]
    new_node.data = child.data[mid:]
    
    # ‡∏ï‡∏±‡∏î keys ‡πÅ‡∏•‡∏∞ data ‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡πÄ‡∏î‡∏¥‡∏°
    child.keys = child.keys[:mid]
    child.data = child.data[:mid]
    
    # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÉ‡∏ö ‡∏ï‡πâ‡∏≠‡∏á‡∏¢‡πâ‡∏≤‡∏¢‡∏•‡∏π‡∏Å‡∏î‡πâ‡∏ß‡∏¢
    if not child.leaf:
        new_node.children = child.children[mid:]
        child.children = child.children[:mid]
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° key ‡πÅ‡∏•‡∏∞ data ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á parent
    parent.keys.insert(i, child.keys[mid])
    parent.data.insert(i, child.data[mid])
    parent.children.insert(i + 1, new_node)
```
### ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 2
1. ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤ 5 ‡∏Ñ‡∏ô ‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏π‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°
   ```python
   class BTreeNode:
    def __init__(self, leaf=True):
        self.leaf = leaf
        self.keys = []
        self.data = []
        self.children = []

   class BTree:
    def __init__(self, order):
        self.root = None
        self.order = order
        
    def get_min_keys(self):
        return (self.order // 2) - 1 if self.order % 2 == 0 else self.order // 2
        
    def get_max_keys(self):
        return self.order - 1

    def insert(self, key, data):
        if self.root is None:
            self.root = BTreeNode()
            self.root.keys.append(key)
            self.root.data.append(data)
            return
        
        if len(self.root.keys) == self.get_max_keys():
            new_root = BTreeNode(leaf=False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        
        self._insert_non_full(self.root, key, data)

    def _insert_non_full(self, node, key, data):
        i = len(node.keys) - 1
        
        if node.leaf:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            node.keys.insert(i, key)
            node.data.insert(i, data)
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            
            if len(node.children[i].keys) == self.get_max_keys():
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
                    
            self._insert_non_full(node.children[i], key, data)

    def _split_child(self, parent, i):
        order = self.order
        child = parent.children[i]
        new_node = BTreeNode(child.leaf)
        mid = order // 2
        
        mid_key = child.keys[mid]
        mid_data = child.data[mid]
        
        new_node.keys = child.keys[mid+1:]
        new_node.data = child.data[mid+1:]
        
        child.keys = child.keys[:mid]
        child.data = child.data[:mid]
        
        if not child.leaf:
            new_node.children = child.children[mid+1:]
            child.children = child.children[:mid+1]
        
        parent.keys.insert(i, mid_key)
        parent.data.insert(i, mid_data)
        parent.children.insert(i + 1, new_node)

    def display(self, node=None, level=0):
        if node is None:
            node = self.root
        print('Level', level, 'Keys:', node.keys)
        for child in node.children:
            self.display(child, level + 1)

   #‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏ó‡∏µ‡πà‡∏°‡∏µ order 3
   btree = BTree(order=3)

   #‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
   num_students = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
   for _ in range(num_students):
    sid = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
    name = input("‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: ")
    btree.insert(sid, name)

   #‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á B-Tree
   btree.display()
   ```
   ![image](https://github.com/user-attachments/assets/55ee0f47-4eb7-4845-b7b7-165d4ed9d5a1)

2. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç class B-Tree ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Entry ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ get_min_keys ‡πÅ‡∏•‡∏∞ get_max_keys
   ```python
   class BTreeNode:
    def __init__(self, leaf=True):
        self.leaf = leaf
        self.keys = []
        self.data = []
        self.children = []

   class BTree:
    def __init__(self, order):
        self.root = None
        self.order = order
        self.max_keys = order - 1  # üîπ ‡∏Ñ‡πà‡∏≤‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÇ‡∏´‡∏ô‡∏î‡∏°‡∏µ‡πÑ‡∏î‡πâ
        self.min_keys = (order // 2) - 1 if order % 2 == 0 else order // 2  # üîπ ‡∏Ñ‡πà‡∏≤‡∏ô‡πâ‡∏≠‡∏¢‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏ô‡∏î‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ

    def insert(self, key, data):
        if self.root is None:
            self.root = BTreeNode()
            self.root.keys.append(key)
            self.root.data.append(data)
            return
        
        if len(self.root.keys) == self.max_keys:
            new_root = BTreeNode(leaf=False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        
        self._insert_non_full(self.root, key, data)

    def _insert_non_full(self, node, key, data):
        i = len(node.keys) - 1
        
        if node.leaf:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            node.keys.insert(i, key)
            node.data.insert(i, data)
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            
            if len(node.children[i].keys) == self.max_keys:
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
                    
            self._insert_non_full(node.children[i], key, data)

    def _split_child(self, parent, i):
        child = parent.children[i]
        new_node = BTreeNode(child.leaf)
        mid = self.order // 2  # üîπ ‡πÉ‡∏ä‡πâ self.order ‡πÅ‡∏ó‡∏ô

        mid_key = child.keys[mid]
        mid_data = child.data[mid]
        
        new_node.keys = child.keys[mid+1:]
        new_node.data = child.data[mid+1:]
        
        child.keys = child.keys[:mid]
        child.data = child.data[:mid]
        
        if not child.leaf:
            new_node.children = child.children[mid+1:]
            child.children = child.children[:mid+1]
        
        parent.keys.insert(i, mid_key)
        parent.data.insert(i, mid_data)
        parent.children.insert(i + 1, new_node)

    def display(self, node=None, level=0):
        if node is None:
            node = self.root
        print('Level', level, 'Keys:', node.keys)
        for child in node.children:
            self.display(child, level + 1)

      # ‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏ó‡∏µ‡πà‡∏°‡∏µ order 3
      btree = BTree(order=3)
      
      # ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
      num_students = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
      for _ in range(num_students):
          sid = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
          name = input("‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: ")
          btree.insert(sid, name)
      
      # ‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á B-Tree
      btree.display()


   ```
   
   ![image](https://github.com/user-attachments/assets/a90244eb-519d-436f-9a20-f220d30d3aea)



### ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 3: ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô B-Tree

```python
def search(self, key):
    """‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å key ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î"""
    def _search_node(node, key):
        i = 0
        # ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
            
        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠ key ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô
        if i < len(node.keys) and key == node.keys[i]:
            return (node, i)
            
        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏ö‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ key
        if node.leaf:
            return None
            
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        return _search_node(node.children[i], key)
    
    if self.root is None:
        return None
        
    result = _search_node(self.root, key)
    if result:
        node, index = result
        return node.data[index]
    return None
```
### ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á
1. ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô B-Tree ‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
   ```python
   class BTreeNode:
    def __init__(self, leaf=True):
        self.leaf = leaf
        self.keys = []
        self.data = []
        self.children = []

   class BTree:
    def __init__(self, order):
        self.root = None
        self.order = order
        self.max_keys = order - 1
        self.min_keys = (order // 2) - 1 if order % 2 == 0 else order // 2

    def insert(self, key, data):
        if self.root is None:
            self.root = BTreeNode()
            self.root.keys.append(key)
            self.root.data.append(data)
            return
        
        if len(self.root.keys) == self.max_keys:
            new_root = BTreeNode(leaf=False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        
        self._insert_non_full(self.root, key, data)

    def _insert_non_full(self, node, key, data):
        i = len(node.keys) - 1
        
        if node.leaf:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            node.keys.insert(i, key)
            node.data.insert(i, data)
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            
            if len(node.children[i].keys) == self.max_keys:
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
                    
            self._insert_non_full(node.children[i], key, data)

    def _split_child(self, parent, i):
        child = parent.children[i]
        new_node = BTreeNode(child.leaf)
        mid = self.order // 2

        mid_key = child.keys[mid]
        mid_data = child.data[mid]
        
        new_node.keys = child.keys[mid+1:]
        new_node.data = child.data[mid+1:]
        
        child.keys = child.keys[:mid]
        child.data = child.data[:mid]
        
        if not child.leaf:
            new_node.children = child.children[mid+1:]
            child.children = child.children[:mid+1]
        
        parent.keys.insert(i, mid_key)
        parent.data.insert(i, mid_data)
        parent.children.insert(i + 1, new_node)

    def display(self, node=None, level=0):
        if node is None:
            node = self.root
        print('Level', level, 'Keys:', node.keys)
        for child in node.children:
            self.display(child, level + 1)

    def search(self, key, node=None):
        """ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô B-Tree ‡∏ï‡∏≤‡∏°‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤ """
        if node is None:
            node = self.root
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and key == node.keys[i]:
            return node.data[i]  # ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•, ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤

        if node.leaf:
            return None  # ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏ö

        return self.search(key, node.children[i])  # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡πà‡∏≠‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏•‡∏π‡∏Å

      # ‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏ó‡∏µ‡πà‡∏°‡∏µ order 3
      btree = BTree(order=3)
      
      # ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
      num_students = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
      for _ in range(num_students):
          sid = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
          name = input("‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: ")
          btree.insert(sid, name)

      # ‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á B-Tree
      btree.display()
      
      # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      search_id = int(input("\n‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤: "))
      result = btree.search(search_id)
      
      if result:
          print(f"‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ‡∏£‡∏´‡∏±‡∏™ {search_id}, ‡∏ä‡∏∑‡πà‡∏≠ {result}")
      else:
          print(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤ {search_id}")


   ```
  ![image](https://github.com/user-attachments/assets/0494adb3-980a-4e5e-b31d-217bbc4762f7)

### ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 4: ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• B-Tree

```python
def display(self):
    def _display(node, level):
        if node:
            # ‡πÅ‡∏™‡∏î‡∏á key ‡πÅ‡∏•‡∏∞ data ‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            print('  ' * level + f"Keys: {node.keys}")
            print('  ' * level + f"Data: {node.data}")
            print('  ' * level + f"Is Leaf: {node.leaf}")
            print('  ' * level + f"Number of children: {len(node.children)}")
            print()
            # ‡πÅ‡∏™‡∏î‡∏á‡∏•‡∏π‡∏Å‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡πÅ‡∏ö‡∏ö recursive
            for child in node.children:
                _display(child, level + 1)
    
    print("B-Tree Structure:")
    _display(self.root, 0)
```
### ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á
1. ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô B-Tree 
   ```python
   class BTreeNode:
    def __init__(self, leaf=True):
        self.leaf = leaf
        self.keys = []      # ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤ (Key)
        self.data = []      # ‡πÄ‡∏Å‡πá‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤ (Value)
        self.children = []  # ‡πÄ‡∏Å‡πá‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏•‡∏π‡∏Å (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)

   class BTree:
    def __init__(self, order):
        self.root = None
        self.order = order
        self.max_keys = order - 1
        self.min_keys = (order // 2) - 1 if order % 2 == 0 else order // 2

    def insert(self, key, data):
        if self.root is None:
            self.root = BTreeNode()
            self.root.keys.append(key)
            self.root.data.append(data)
            return
        
        if len(self.root.keys) == self.max_keys:
            new_root = BTreeNode(leaf=False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        
        self._insert_non_full(self.root, key, data)

    def _insert_non_full(self, node, key, data):
        i = len(node.keys) - 1
        
        if node.leaf:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            node.keys.insert(i, key)
            node.data.insert(i, data)
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            
            if len(node.children[i].keys) == self.max_keys:
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
                    
            self._insert_non_full(node.children[i], key, data)

    def _split_child(self, parent, i):
        child = parent.children[i]
        new_node = BTreeNode(child.leaf)
        mid = self.order // 2

        mid_key = child.keys[mid]
        mid_data = child.data[mid]
        
        new_node.keys = child.keys[mid+1:]
        new_node.data = child.data[mid+1:]
        
        child.keys = child.keys[:mid]
        child.data = child.data[:mid]
        
        if not child.leaf:
            new_node.children = child.children[mid+1:]
            child.children = child.children[:mid+1]
        
        parent.keys.insert(i, mid_key)
        parent.data.insert(i, mid_data)
        parent.children.insert(i + 1, new_node)

    def display(self, node=None, level=0):
        """ ‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á B-Tree ‡πÅ‡∏ö‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ä‡∏±‡πâ‡∏ô """
        if node is None:
            node = self.root
        print('Level', level, 'Keys:', node.keys, 'Data:', node.data)
        for child in node.children:
            self.display(child, level + 1)

    def display_all_data(self, node=None):
        """ ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô B-Tree """
        if node is None:
            node = self.root
        if node.leaf:
            for i in range(len(node.keys)):
                print(f"‡∏£‡∏´‡∏±‡∏™: {node.keys[i]}, ‡∏ä‡∏∑‡πà‡∏≠: {node.data[i]}")
        else:
            for i in range(len(node.keys)):
                self.display_all_data(node.children[i])
                print(f"‡∏£‡∏´‡∏±‡∏™: {node.keys[i]}, ‡∏ä‡∏∑‡πà‡∏≠: {node.data[i]}")
            self.display_all_data(node.children[-1])

      # ‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏ó‡∏µ‡πà‡∏°‡∏µ order = 3
      btree = BTree(order=3)
      
      # ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
      num_students = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
      for _ in range(num_students):
          sid = int(input("‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: "))
          name = input("‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: ")
          btree.insert(sid, name)
      
      # ‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á B-Tree
      print("\nüîπ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á B-Tree:")
      btree.display()
      
      # ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
      print("\nüîπ ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô B-Tree:")
      btree.display_all_data()
      

   ```
   ![image](https://github.com/user-attachments/assets/2923f61c-c268-4246-8746-1b119a55643b)

### ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏ó‡∏µ‡πà 5: ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á :‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤

```python
# ‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô
registration_system = BTree(order=3)

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤
def register_student(student_id, info):
    registration_system.insert(student_id, {
        "name": info["name"],
        "gpa": info["gpa"],
        "courses": info["courses"]
    })

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
register_student(6301, {
    "name": "‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡πÉ‡∏à‡∏î‡∏µ",
    "gpa": 3.75,
    "courses": ["CS101", "CS102"]
})

register_student(6302, {
    "name": "‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á ‡∏£‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô",
    "gpa": 3.85,
    "courses": ["CS101", "MATH101"]
})

# ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤
def get_student_info(student_id):
    student = registration_system.search(student_id)
    if student:
        print(f"‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤: {student_id}")
        print(f"‡∏ä‡∏∑‡πà‡∏≠: {student['name']}")
        print(f"‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢: {student['gpa']}")
        print(f"‡∏ß‡∏¥‡∏ä‡∏≤‡∏ó‡∏µ‡πà‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô: {', '.join(student['courses'])}")
    else:
        print(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏£‡∏´‡∏±‡∏™ {student_id}")

# ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
get_student_info(6301)
```

## ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î
1. ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (key ‡πÅ‡∏•‡∏∞ data) ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å B-Tree
 ```python
class BTreeNode:
    def __init__(self, leaf=True):
        self.leaf = leaf
        self.keys = []
        self.data = []
        self.children = []

class BTree:
    def __init__(self, order):
        self.root = None
        self.order = order
        self.max_keys = order - 1
        self.min_keys = (order // 2) - 1 if order % 2 == 0 else order // 2

    def insert(self, key, data):
        if self.root is None:
            self.root = BTreeNode()
            self.root.keys.append(key)
            self.root.data.append(data)
            return
        
        if len(self.root.keys) == self.max_keys:
            new_root = BTreeNode(leaf=False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        
        self._insert_non_full(self.root, key, data)

    def _insert_non_full(self, node, key, data):
        i = len(node.keys) - 1
        
        if node.leaf:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            node.keys.insert(i, key)
            node.data.insert(i, data)
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            
            if len(node.children[i].keys) == self.max_keys:
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
                    
            self._insert_non_full(node.children[i], key, data)

    def _split_child(self, parent, i):
        child = parent.children[i]
        new_node = BTreeNode(child.leaf)
        mid = self.order // 2

        mid_key = child.keys[mid]
        mid_data = child.data[mid]
        
        new_node.keys = child.keys[mid+1:]
        new_node.data = child.data[mid+1:]
        
        child.keys = child.keys[:mid]
        child.data = child.data[:mid]
        
        if not child.leaf:
            new_node.children = child.children[mid+1:]
            child.children = child.children[:mid+1]
        
        parent.keys.insert(i, mid_key)
        parent.data.insert(i, mid_data)
        parent.children.insert(i + 1, new_node)

    def display(self, node=None, level=0):
        if node is None:
            node = self.root
        print('Level', level, 'Keys:', node.keys, 'Data:', node.data)
        for child in node.children:
            self.display(child, level + 1)

    def delete(self, key, node=None):
        """ ‡∏•‡∏ö key ‡πÅ‡∏•‡∏∞ data ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å B-Tree """
        if self.root is None:
            print("‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏•‡∏ö")
            return

        if node is None:
            node = self.root

        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        # üîπ 1. ‡∏ñ‡πâ‡∏≤ key ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        if i < len(node.keys) and node.keys[i] == key:
            if node.leaf:
                # üî∏ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡πÉ‡∏ö ‡∏•‡∏ö key ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
                del node.keys[i]
                del node.data[i]
            else:
                # üî∏ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô ‡πÉ‡∏ä‡πâ Predecessor ‡∏´‡∏£‡∏∑‡∏≠ Successor
                if len(node.children[i].keys) >= self.min_keys + 1:
                    pred_key, pred_data = self._get_predecessor(node.children[i])
                    node.keys[i], node.data[i] = pred_key, pred_data
                    self.delete(pred_key, node.children[i])
                elif len(node.children[i+1].keys) >= self.min_keys + 1:
                    succ_key, succ_data = self._get_successor(node.children[i+1])
                    node.keys[i], node.data[i] = succ_key, succ_data
                    self.delete(succ_key, node.children[i+1])
                else:
                    # üî∏ ‡∏£‡∏ß‡∏°‡πÇ‡∏´‡∏ô‡∏î‡∏ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏°‡∏µ key ‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                    self._merge_nodes(node, i)
                    self.delete(key, node.children[i])
        else:
            # üîπ 2. ‡∏ñ‡πâ‡∏≤ key ‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
            if node.leaf:
                print(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏´‡∏±‡∏™ {key} ‡πÉ‡∏ô B-Tree")
                return

            child = node.children[i]
            if len(child.keys) == self.min_keys:
                # üîπ ‡∏î‡∏∂‡∏á key ‡∏à‡∏≤‡∏Å‡∏û‡∏µ‡πà‡∏ô‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏ß‡∏°‡πÇ‡∏´‡∏ô‡∏î‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
                self._balance_child(node, i)

            self.delete(key, node.children[i])

    def _get_predecessor(self, node):
        """ ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡∏ã‡πâ‡∏≤‡∏¢ (Predecessor) """
        while not node.leaf:
            node = node.children[-1]
        return node.keys[-1], node.data[-1]

    def _get_successor(self, node):
        """ ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡∏Ç‡∏ß‡∏≤ (Successor) """
        while not node.leaf:
            node = node.children[0]
        return node.keys[0], node.data[0]

    def _merge_nodes(self, parent, i):
        """ ‡∏£‡∏ß‡∏°‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà key ‡πÑ‡∏°‡πà‡∏û‡∏≠ """
        child = parent.children[i]
        sibling = parent.children[i+1]

        child.keys.append(parent.keys[i])
        child.data.append(parent.data[i])
        child.keys.extend(sibling.keys)
        child.data.extend(sibling.data)

        if not child.leaf:
            child.children.extend(sibling.children)

        del parent.keys[i]
        del parent.data[i]
        del parent.children[i+1]

    def _balance_child(self, parent, i):
        """ ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏ô‡∏î‡∏•‡∏π‡∏Å """
        child = parent.children[i]
        if i > 0 and len(parent.children[i-1].keys) > self.min_keys:
            sibling = parent.children[i-1]
            child.keys.insert(0, parent.keys[i-1])
            child.data.insert(0, parent.data[i-1])
            parent.keys[i-1] = sibling.keys.pop()
            parent.data[i-1] = sibling.data.pop()
            if not sibling.leaf:
                child.children.insert(0, sibling.children.pop())
        elif i < len(parent.children)-1 and len(parent.children[i+1].keys) > self.min_keys:
            sibling = parent.children[i+1]
            child.keys.append(parent.keys[i])
            child.data.append(parent.data[i])
            parent.keys[i] = sibling.keys.pop(0)
            parent.data[i] = sibling.data.pop(0)
            if not sibling.leaf:
                child.children.append(sibling.children.pop(0))
        else:
            self._merge_nodes(parent, i)

      # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      btree = BTree(order=3)
      students = [(101, "Alice"), (203, "Bob"), (150, "Charlie"), (99, "David"), (175, "Eve")]
      for sid, name in students:
          btree.insert(sid, name)
      
      print("\nüîπ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö:")
      btree.display()
      
      delete_id = int(input("\n‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö: "))
      btree.delete(delete_id)
      
      print("\nüîπ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á B-Tree ‡∏´‡∏•‡∏±‡∏á‡∏•‡∏ö:")
      btree.display()


```
2. ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (data) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö key ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
3. ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô B-Tree ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° key
4. ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö‡∏ä‡πà‡∏ß‡∏á (range search)
   
